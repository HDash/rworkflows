URL <- paste(
"https://github.com/",
co_notag,
"/pkgs/container/",basename(co_notag),
"/versions?filters%5Bversion_type%5D=tagged"
)
x <- rvest::read_html(URL)
URL
##### Only works if you have permissions to the repo #####
# get_ghcr_tags <- function(container) {
#   url <- paste0("https://ghcr.io/v2/", container, "/tags/list")
#   response <- jsonlite::fromJSON(url)
#   tags <- response$tags
#   return(tags)
# }
# get_ghcr_tags("bioconductor/bioconductor_docker")
#
URL <- paste0(
"https://github.com/",
co_notag,
"/pkgs/container/",basename(co_notag),
"/versions?filters%5Bversion_type%5D=tagged"
)
x <- rvest::read_html(URL)
x
### get all nodes of class "Label"
tags <- x |> rvest::html_nodes(".Label") |> rvest::html_text()
tags
x <- tryCatch({
rvest::read_html(URL)
}, error=function(e){
stopper("Unable to find public container:",co)}
)
x
splt <- strsplit(co,":")[[1]]
splt
source("~/Desktop/rworkflows/R/check_tags.R")
check_tags(tags = tags,
splt = splt,
verbose = verbose)
verbose=T
check_tags(tags = tags,
splt = splt,
verbose = verbose)
# co <- "ghcr.io/bioconductor/bioconductor_docker:devel"
co_notag <- gsub("ghcr.io/","",strsplit(co,":")[[1]][1])
##### Only works if you have permissions to the repo #####
# get_ghcr_tags <- function(container) {
#   url <- paste0("https://ghcr.io/v2/", container, "/tags/list")
#   response <- jsonlite::fromJSON(url)
#   tags <- response$tags
#   return(tags)
# }
# tags <- get_ghcr_tags("bioconductor/bioconductor_docker")
#
URL <- paste0(
"https://github.com/",
co_notag,
"/pkgs/container/",basename(co_notag),
"/versions?filters%5Bversion_type%5D=tagged"
)
x <- tryCatch({
rvest::read_html(URL)
}, error=function(e){
stopper("Unable to find public container:",co)}
)
### get all nodes of class "Label"
tags <- x |> rvest::html_nodes(".Label") |> rvest::html_text()
if(length(tags)==0){
stopper("Unable to find public container:",co)
}
strsplit(co,":")[[1]]
strsplit(co,":")[[2]]
check_tags(tags = tags,
splt = strsplit(co,":")[[1]],
verbose = verbose)
tags
check_tags(tags = tags,
splt = strsplit(co,":")[[1]][1],
verbose = verbose)
strsplit(co,":")[[1]][1]
check_tags(tags = tags,
splt = c("ew","wefwe"),
verbose = verbose)
tags
co
for(co in cont){
# co <- "ghcr.io/bioconductor/bioconductor_docker:devel"
co_notag <- gsub("ghcr.io/","",strsplit(co,":")[[1]][1])
##### Only works if you have permissions to the repo #####
# get_ghcr_tags <- function(container) {
#   url <- paste0("https://ghcr.io/v2/", container, "/tags/list")
#   response <- jsonlite::fromJSON(url)
#   tags <- response$tags
#   return(tags)
# }
# tags <- get_ghcr_tags("bioconductor/bioconductor_docker")
#
URL <- paste0(
"https://github.com/",
co_notag,
"/pkgs/container/",basename(co_notag),
"/versions?filters%5Bversion_type%5D=tagged"
)
x <- tryCatch({
rvest::read_html(URL)
}, error=function(e){
stopper("Unable to find public container:",co)}
)
### get all nodes of class "Label"
tags <- x |> rvest::html_nodes(".Label") |> rvest::html_text()
if(length(tags)==0){
stopper("Unable to find tags for container:",co)
} else {
check_tags(tags = tags,
splt = strsplit(co,":")[[1]][1],
verbose = verbose)
}
}
messager("Unable to check container registry",
default_registry,
"for container",
cont,
"Skipping check.",
v=verbose)
#### Check args ####
default_registry <- check_registry(default_registry)
devoptera::args2vars(check_cont)
#### Check args ####
default_registry <- check_registry(default_registry)
source("~/Desktop/rworkflows/R/check_cont_ghcr.R")
check_cont
# devoptera::args2vars(check_cont)
cont = "rocker/r-ver:4.0.5"
#### Check args ####
default_registry <- check_registry(default_registry)
check_cont_ghcr(cont = cont,
verbose = verbose)
#### Check args ####
default_registry <- check_registry(default_registry)
cont <- list("ghcr.io/bioconductor/bioconductor_docker:devel" )
#### Check container ####
if(grep("docker.io",default_registry)){
check_cont_dockerhub(cont = cont,
verbose = verbose)
} else if(grep("ghcr.io",default_registry)){
check_cont_ghcr(cont = cont,
verbose = verbose)
} else {
messager("Unable to check container registry",
default_registry,
"for container",
cont,
"Skipping check.",
v=verbose)
}
default_registry
grep("docker.io",default_registry)
#### Check container ####
if(grepl("docker.io",default_registry)){
check_cont_dockerhub(cont = cont,
verbose = verbose)
} else if(grepl("ghcr.io",default_registry)){
check_cont_ghcr(cont = cont,
verbose = verbose)
} else {
messager("Unable to check container registry",
default_registry,
"for container",
cont,
"Skipping check.",
v=verbose)
}
check_cont_ghcr(cont = cont,
verbose = verbose)
usethis::use_test()
devtools::check_man()
library(rworkflows)
check_cont(cont = "ghcr.io/bioconductor/bioconductor_docker")
rworkflows:::check_cont(cont = "ghcr.io/bioconductor/bioconductor_docker")
#### Include registry ####
testthat::expect_no_warning(
rworkflows:::check_cont(cont = "ghcr.io/bioconductor/bioconductor_docker")
)
testthat::expect_no_warning(
check_cont(cont = "docker.io/bioconductor/bioconductor_docker:devel")
)
testthat::expect_no_warning(
rworkflows:::check_cont(cont = "docker.io/bioconductor/bioconductor_docker:devel")
)
testthat::expect_no_warning(
rworkflows:::check_cont(cont = "docker.io/bioconductor/bioconductor_docker:devel")
)
devoptera::args2vars(check_cont)
check_cont(cont = "docker.io/bioconductor/bioconductor_docker:devel")
cont = "docker.io/bioconductor/bioconductor_docker:devel"
grepl("docker.io",default_registry)
#### Check args ####
default_registry <- check_registry(default_registry)
default_registry
cont
check_cont_ghcr(cont = cont,
verbose = verbose)
for(co in cont){
# co <- "ghcr.io/bioconductor/bioconductor_docker:devel"
co_notag <- gsub("ghcr.io/","",strsplit(co,":")[[1]][1])
##### Only works if you have permissions to the repo #####
# get_ghcr_tags <- function(container) {
#   url <- paste0("https://ghcr.io/v2/", container, "/tags/list")
#   response <- jsonlite::fromJSON(url)
#   tags <- response$tags
#   return(tags)
# }
# tags <- get_ghcr_tags("bioconductor/bioconductor_docker")
#
URL <- paste0(
"https://github.com/",
co_notag,
"/pkgs/container/",basename(co_notag),
"/versions?filters%5Bversion_type%5D=tagged"
)
#### Check if container exists ####
x <- tryCatch({
rvest::read_html(URL)
}, error=function(e){
stopper("Unable to find public container:",co)}
)
#### Check if container has tags ####
tags <- x |> rvest::html_nodes(".Label") |> rvest::html_text()
if(length(tags)==0){
stopper("Unable to find tags for container:",co)
} else {
check_tags(tags = tags,
splt = strsplit(co,":")[[1]][1],
verbose = verbose)
}
}
# co <- "ghcr.io/bioconductor/bioconductor_docker:devel"
co_notag <- gsub("ghcr.io/","",strsplit(co,":")[[1]][1])
grepl("ghcr.io",cont)
check_cont_dockerhub(cont = cont,
verbose = verbose)
devtools::check_man()
library(rworkflows)
#### Include registry ####
testthat::expect_no_warning(
rworkflows:::check_cont(cont = "ghcr.io/bioconductor/bioconductor_docker")
)
testthat::expect_no_warning(
rworkflows:::check_cont(cont = "docker.io/bioconductor/bioconductor_docker:devel")
)
testthat::expect_no_warning(
rworkflows:::check_cont(cont = "docker.io/bioconductor/bioconductor_docker:devel")
)
library(rworkflows)
testthat::expect_no_warning(
check_cont(cont = "bioconductor/bioconductor_docker:devel")
)
check_cont_general <- function(cont){
for(co in cont){
if(is.null(co)) next()
if(isFALSE(grepl("/",co))){
stopper("Container must be specified in the following format:",
"'registry/owner/repo:tag'")
}
}
}
check_cont_general(cont)
devtools::document()
library(rworkflows)
cont
cont <- list("ghcr.io/bioconductor/bioconductor_docker:devel" )
strsplit(cont,"/")
# devoptera::args2vars(check_cont)
# cont <- list("ghcr.io/bioconductor/bioconductor_docker:devel" )
strsplit(cont,"/")[[1]][1]
cont
# devoptera::args2vars(check_cont)
# cont <- list("ghcr.io/bioconductor/bioconductor_docker:devel" )
strsplit(cont,"/")
# devoptera::args2vars(check_cont)
# cont <- list("ghcr.io/bioconductor/bioconductor_docker:devel" )
strsplit(cont[[1]],"/")
gsub("[/]+","/",cont)
strsplit(gsub("[/]+","/",cont),"/")[[1]]
# devoptera::args2vars(check_cont)
# cont <- list("ghcr.io/bioconductor/bioconductor_docker:devel" )
n_parts <- strsplit(gsub("[/]+","/",cont),"/")[[1]]
source("~/Desktop/rworkflows/R/check_cont_general.R")
check_cont_general(cont)
source("~/Desktop/rworkflows/R/check_cont_general.R")
cont
check_cont_general(cont)
lapply(cont, function(co)){
source("~/Desktop/rworkflows/R/check_cont_general.R")
check_cont_general(cont)
n_parts <- check_cont_general(cont)
n_parts
for(co in cont){
#### Check container ####
if(grepl("ghcr.io",co)){
check_cont_ghcr(cont = co,
verbose = verbose)
} else if(grepl("docker.io",cont)){
check_cont_dockerhub(cont = co,
verbose = verbose)
} else if(n_parts==2){
messager("Assuming container is on DockerHub.",v=verbose)
check_cont_dockerhub(cont = co,
verbose = verbose)
} else {
warning(paste(
"Unable to check registry for container",co,
"Skipping check."
))
}
}
source("~/Desktop/rworkflows/R/check_cont_ghcr.R")
n_parts <- check_cont_general(cont)
for(co in cont){
#### Check container ####
if(grepl("ghcr.io",co)){
check_cont_ghcr(cont = co,
verbose = verbose)
} else if(grepl("docker.io",cont)){
check_cont_dockerhub(cont = co,
verbose = verbose)
} else if(n_parts==2){
messager("Assuming container is on DockerHub.",v=verbose)
check_cont_dockerhub(cont = co,
verbose = verbose)
} else {
warning(paste(
"Unable to check registry for container",co,
"Skipping check."
))
}
}
devoptera::args2vars(check_cont)
for(co in cont){
#### Check container ####
if(grepl("ghcr.io",co)){
check_cont_ghcr(cont = co,
verbose = verbose)
} else if(grepl("docker.io",cont)){
check_cont_dockerhub(cont = co,
verbose = verbose)
} else if(n_parts==2){
messager("Assuming container is on DockerHub.",v=verbose)
check_cont_dockerhub(cont = co,
verbose = verbose)
} else {
warning(paste(
"Unable to check registry for container",co,
"Skipping check."
))
}
}
testthat::expect_error(
check_cont(cont = "typooooo")
)
check_cont(cont = "typooooo")
devtools::check_man()
library(rworkflows)
library(rworkflows)
run_tests <- function(runners){
testthat::expect_length(runners,3)
for (r in runners){
testthat::expect_true(all(c("os","bioc","r") %in% names(r)))
}
}
runners <- construct_runners()
run_tests(runners = runners)
testthat::expect_error(
construct_runners(bioc=list("typo"="typo"))
)
testthat::expect_error(
construct_runners(r=list("typo"="typo"))
)
testthat::expect_error(
construct_runners(cont=list("typo"="typo"))
)
#### versions_explicit ####
runners <- construct_runners(versions_explicit = TRUE)
run_tests(runners = runners)
testthat::expect_true(
package_version(runners[[1]]$r)>="4.3"
)
testthat::expect_true(
package_version(runners[[1]]$bioc)>="3.17"
)
#### When only single opts given ####
runners <- construct_runners(bioc = "devel",
versions_explicit = TRUE,
run_check_cont = TRUE)
library(rworkflows)
cont1 <- construct_cont()
testthat::expect_equal(cont1[[1]],  "bioconductor/bioconductor_docker:devel")
opts <- eval(formals(construct_cont)$default_registry)[1]
opts
testthat::expect_equal(cont1[[1]],  paste(opts,"bioconductor/bioconductor_docker:latest"))
testthat::expect_equal(cont1[[1]],  paste(opts,"bioconductor/bioconductor_docker:latest",sep="/"))
testthat::expect_equal(cont1[[1]],  paste(opts,"bioconductor/bioconductor_docker:devel",sep="/"))
testthat::expect_equal(cont1[[1]],  paste0(opts,"bioconductor/bioconductor_docker:devel"))
testthat::expect_null(cont1[[2]])
testthat::expect_null(cont1[[3]])
cont2 <- construct_cont(cont = "devel")
testthat::expect_equal(cont2[[1]],  "bioconductor/bioconductor_docker:devel")
testthat::expect_equal(cont2[[1]],  paste0(opts,"bioconductor/bioconductor_docker:devel"))
cont3 <- construct_cont(versions_explicit = TRUE)
testthat::expect_true(grepl("bioconductor/bioconductor_docker:RELEASE_*",
cont3[[1]]))
testthat::expect_null(cont3[[2]])
testthat::expect_null(cont3[[3]])
cont4 <- construct_cont(default_tag = "release",
run_check_cont = TRUE)
testthat::expect_equal(cont4[[1]],  "bioconductor/bioconductor_docker:latest")
testthat::expect_equal(cont4[[1]], paste0(opts,"bioconductor/bioconductor_docker:latest"))
testthat::expect_null(cont4[[2]])
testthat::expect_null(cont4[[3]])
default_tag <- eval(formals(construct_cont)$default_tag)[1]
default_tag
testthat::expect_equal(cont1[[1]],  paste0(opts,"bioconductor/bioconductor_docker:",default_tag)))
testthat::expect_equal(cont1[[1]],  paste0(opts,"bioconductor/bioconductor_docker:",default_tag))
cont1 <- construct_cont()
default_registry <- eval(formals(construct_cont)$default_registry)[1]
default_tag <- eval(formals(construct_cont)$default_tag)[1]
testthat::expect_equal(cont1[[1]],
paste0(opts,"bioconductor/bioconductor_docker:",default_tag))
testthat::expect_null(cont1[[2]])
testthat::expect_null(cont1[[3]])
cont2 <- construct_cont(cont = "devel")
testthat::expect_equal(cont2[[1]],
paste0(opts,"bioconductor/bioconductor_docker:",default_tag))
cont3 <- construct_cont(versions_explicit = TRUE)
testthat::expect_true(grepl("bioconductor/bioconductor_docker:RELEASE_*",
cont3[[1]]))
testthat::expect_null(cont3[[2]])
testthat::expect_null(cont3[[3]])
cont4 <- construct_cont(default_tag = "release",
run_check_cont = TRUE)
testthat::expect_equal(cont4[[1]], paste0(opts,"bioconductor/bioconductor_docker:latest"))
testthat::expect_null(cont4[[2]])
testthat::expect_null(cont4[[3]])
devtools::check_man()
library(rworkflows)
devoptera::args2vars(use_dockerfile)
messager("Creating new Docker file ==>",path,v=verbose)
save_dir=tempdir()
file.copy(from = system.file("templates","Dockerfile",
package = "rworkflows"),
to = path,
overwrite = TRUE)
path
readLines(path)
txt <- readLines(path)
construct_cont()
construct_cont()[[1]]
base_image=construct_cont()[[1]]
base_image
gsub("^FROM*",paste0("FROM",base_image),txt)
gsub("^FROM*",paste("FROM",base_image),txt)
gsub("^FROM {BASE_IMAGE}",paste("FROM",base_image),txt)
gsub("^FROM \\{BASE_IMAGE\\}",paste("FROM",base_image),txt)
writeLines(txt,path)
library(rworkflows)
devtools::check_man()
library(rworkflows)
path <- use_dockerfile(save_dir=tempdir())
path <- use_dockerfile(save_dir=tempdir(), preview=TRUE)
#' (default: \code{FALSE}).
#' @param show Print the contents of the Docker file in the R console.
#' @param verbose Print messages.
#' @returns Path to Docker file.
#'
#' @export
#' @importFrom utils download.file
#' @importFrom here here
#' @examples
#' path <- use_dockerfile(save_dir=tempdir(), preview=TRUE)
use_dockerfile <- function(save_dir=here::here(),
path=file.path(save_dir,"Dockerfile"),
base_image=construct_cont()[[1]],
force_new=FALSE,
show=FALSE,
verbose=TRUE){
# devoptera::args2vars(use_dockerfile)
if(file.exists(path) &&
isFALSE(force_new)){
messager("Using existing Docker file:",path,v=verbose)
} else {
messager("Creating new Docker file ==>",path,v=verbose)
dir.create(dirname(path), showWarnings = FALSE, recursive = TRUE)
file.copy(from = system.file("templates","Dockerfile",
package = "rworkflows"),
to = path,
overwrite = TRUE)
txt <- readLines(path)
txt <- gsub("^FROM \\{BASE_IMAGE\\}",paste("FROM",base_image),txt)
writeLines(txt,path)
}
if(isTRUE(show)){
messager("Docker file preview:",v=verbose)
cat(paste(readLines(path),collapse ="\n"))
}
return(path)
}
path <- use_dockerfile(save_dir=tempdir(), preview=TRUE)
path <- use_dockerfile(save_dir=tempdir(), show=TRUE)
library(rworkflows)
path <- use_dockerfile(save_dir=tempdir(), show=TRUE)
library(rworkflows)
