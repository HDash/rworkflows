testthat::expect_equal(d4$rworkflows,
d1$`neurogenomics/rworkflows`)
testthat::expect_null(d5$typoooo)
testthat::expect_null(d6[[1]])
if(is_gha() && testthat::is_testing()){
testthat::expect_equal(d7[[1]],
d1[[1]])
} else if(testthat::is_testing()){
testthat::expect_null(d7[[1]])
}
library(rworkflows)
d10 <- get_description(refs="ggtree",
use_wd = FALSE,
use_repos = TRUE)
devoptera::args2vars(get_description_repo, reassign = TRUE)
refs="ggtree"
force(refs)
messager("Searching for DESCRIPTION file(s) in R repositories:",
paste(repo,collapse = ", "),v=verbose)
tmp_dir <- file.path(tempdir(),"BiocPkgTools")
dir.create(tmp_dir,showWarnings = FALSE, recursive = TRUE)
#### Import each database ####
db <- lapply(stats::setNames(repo,repo), function(x){
messager("Importing database:",x,v=verbose)
#### Cache a local copy ####
tmp <- file.path(tmp_dir,paste0(x,".rds"))
if(file.exists(tmp)){
db_i <- readRDS(tmp)
} else {
db_i <- BiocPkgTools::biocPkgList(repo=x,
version = version) |>
suppressMessages() |>
suppressWarnings()
saveRDS(db_i, tmp)
}
return(db_i)
}) |> data.table::rbindlist(fill = TRUE, use.names = TRUE, idcol = "r_repo")
if(!is.null(refs)) db <- db[Package %in% basename(refs),]
if(nrow(db)==0) {
messager("0 DESCRIPTION files found in CRAN/Bioc.",
"Returning NULL.",v=verbose)
return(NULL)
}
#### Parse GitHub URL #####
db <- get_github_url_db(db = db, return_dt = TRUE)
#### Split GitHub URL ####
db <- cbind(db,BiocPkgTools::githubURLParts(urls = db$url_github))
data.table::setnames(db,c("user_repo","user"),c("owner_repo","owner"),
skip_absent = TRUE)
dt_to_desc(db = db,
refs = refs,
verbose = verbose)
db <- data.table::as.data.table(db)
if(is.null(refs)){
refs <- db$Package
}else{
refs <- refs[basename(refs) %in% db$Package]
}
messager("Constructing DESCRIPTION files for",
formatC(length(refs),big.mark = ","),"R packages.",v=verbose)
valid_fields <-desc::cran_valid_fields
lapply(stats::setNames(basename(refs),
refs),
function(p){
messager("Constructing DESCRIPTION for:",p,v=verbose)
db_sub <- db[Package==p,][1,]
d <- desc::description$new("!new")
for(k in names(db_sub)){
vals <- db_sub[[k]]
if(is.list(vals)) vals <- unlist(vals)
vals <- vals[vals!=""]
if(k %in% valid_fields &&
!all(is.na(vals))){
d$set_list(key = k,
list_value = vals)
}
}
d
})
p=refs
messager("Constructing DESCRIPTION for:",p,v=verbose)
db_sub <- db[Package==p,][1,]
d <- desc::description$new("!new")
for(k in names(db_sub)){
vals <- db_sub[[k]]
if(is.list(vals)) vals <- unlist(vals)
vals <- vals[vals!=""]
if(k %in% valid_fields &&
!all(is.na(vals))){
d$set_list(key = k,
list_value = vals)
}
}
vals <- db_sub[[k]]
if(is.list(vals)) vals <- unlist(vals)
vals <- vals[vals!=""]
if(k %in% valid_fields &&
!all(is.na(vals))){
d$set_list(key = k,
list_value = vals)
}
d <- desc::description$new("!new")
for(k in names(db_sub)){
vals <- db_sub[[k]]
if(is.list(vals)) vals <- unlist(vals)
vals <- vals[vals!=""]
if(k %in% valid_fields &&
!all(is.na(vals))){
d$set_list(key = k,
list_value = vals)
}
}
names(db_sub)
k
k="Description"
vals <- db_sub[[k]]
if(is.list(vals)) vals <- unlist(vals)
vals <- vals[vals!=""]
vals
d$set_list(key = k,
list_value = vals)|> suppressWarnings()
lapply(stats::setNames(basename(refs),
refs),
function(p){
messager("Constructing DESCRIPTION for:",p,v=verbose)
db_sub <- db[Package==p,][1,]
d <- desc::description$new("!new")
for(k in names(db_sub)){
vals <- db_sub[[k]]
if(is.list(vals)) vals <- unlist(vals)
vals <- vals[vals!=""]
if(k %in% valid_fields &&
!all(is.na(vals))){
d$set_list(key = k,
list_value = vals) |>
suppressWarnings()
}
}
d
})
usethis::use_test()
hex1 <- get_hex(refs="neurogenomics/rworkflows")
hex2 <- get_hex(refs="rworkflows")
hex3 <- get_hex(refs=NULL,
paths=here::here("DESCRIPTION"))
hex4 <- get_hex(refs=NULL,
paths=NULL)
testthat::expect_equal(hex2$rworkflows,
hex1$`neurogenomics/rworkflows`)
if(is_gha() && testthat::is_testing()){
testthat::expect_equal(hex3[[1]],
hex1[[1]])
} else {
testthat::expect_null(hex3[[1]])
}
hex3
testthat::expect_equal(hex3[[1]],
hex1[[1]])
hex3[[1]]
hex3[[1]]
hex1[[1]]
library(rworkflows)
usethis::use_test()
save_dir=here::here()
path=file.path(save_dir,
"vignettes",
"docker.Rmd")
path <- normalizePath(path)
path
usethis::use_test()
d7 <- get_description(refs=NULL,
paths=here::here("DESCRIPTION")
)
d7
devtools::document()
library(rworkflows)
use_workflow(name = "rworkflows_static", run_pkgdown = F, force_new = T)
devoptera::args2vars(use_workflow)
docker_org <- eval(docker_org)
name="rworkflows_static"
#### Check for existing yaml ####
path <- file.path(save_dir,paste0(name,".yml"))
if(file.exists(path) &&
isFALSE(force_new)){
messager("Using existing workflow file:",path,v=verbose)
yml <- yaml::read_yaml(path)
#### Preview ####
if(isTRUE(preview)){
cat(yaml::as.yaml(yml))
}
#### Return ####
if(isTRUE(return_path)){
return(path)
} else {
return(yml)
}
}
## Custom handler prevents "on" from being converted to TRUE
yml <- get_yaml(name = name)
yml
workflow_nms <- c("rworkflows","rworkflows_static")
handlers <- list('bool#yes' = function(x) { if (x == "on") x else TRUE})
yml <- yaml::read_yaml(
system.file("templates","rworkflows_template_static.yml",
package = "rworkflows"),
handlers = handlers)
yml
#### Add action steps to static workflow ####
yml$jobs$rworkflows_static$steps <- action$runs$steps
yml$jobs$rworkflows_static$steps
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
#### Add action steps to static workflow ####
yml$jobs$rworkflows_static$steps <- action$runs$steps
action$runs$steps
action$runs$steps[[1]]
action$runs$steps[[1]]$run
#### Add action steps to static workflow ####
cat(action$runs$steps[[1]]$run)
#### Add action steps to static workflow ####
action$runs$steps[[1]]$run <- cat(action$runs$steps[[1]]$run)
action$runs$steps[[1]]$run
action$runs$steps[[1]]$run
cat(action$runs$steps[[1]]$run)
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
cat(action$runs$steps[[1]]$run)
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
action$runs$steps[[1]]$run
cat(action$runs$steps[[1]]$run)
capture.output(cat(action$runs$steps[[1]]$run))
cat(action$runs$steps[[1]]$run)
message(cat(action$runs$steps[[1]]$run))
capture.output(message(cat(action$runs$steps[[1]]$run)))
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
message(cat(action$runs$steps[[1]]$run))
action$runs$steps[[1]]$run
cat(action$runs$steps[[1]]$run)
capture.output(cat(action$runs$steps[[1]]$run))
action$runs$steps[[2]]$run
#### Add action steps to static workflow ####
# action$runs$steps[[1]]$run <- capture.output(cat(action$runs$steps[[1]]$run))
yml$jobs$rworkflows_static$steps <- action$runs$steps
## Custom handler prevents "on" from being converted to TRUE
yml <- get_yaml(name = name)
yml <- fill_yaml(yml=yml,
## action-level args
name=name,
tag=tag,
on=on,
branches=branches,
runners=runners,
## workflow-level args
run_bioccheck=run_bioccheck,
run_rcmdcheck=run_rcmdcheck,
as_cran=as_cran,
run_vignettes=run_vignettes,
has_testthat=has_testthat,
run_covr=run_covr,
run_pkgdown=run_pkgdown,
has_runit=has_runit,
has_latex=has_latex,
run_docker=run_docker,
github_token=github_token,
docker_user=docker_user,
docker_org=docker_org,
docker_token=docker_token,
cache_version=cache_version,
enable_act=enable_act)
cat(yaml::as.yaml(yml))
dir.create(dirname(path),showWarnings = FALSE, recursive = TRUE)
messager("Saving workflow ==>",path,v=verbose)
path="~/Downloads/yaml.yml"
dir.create(dirname(path),showWarnings = FALSE, recursive = TRUE)
messager("Saving workflow ==>",path,v=verbose)
#### Write bools as true/false rather than yes/no (default) ####
handlers2 <- list('bool#yes' = function(x){"${{ true }}"},
'bool#no' = function(x){"${{ false }}"})
yml2 <- yaml::yaml.load(yaml::as.yaml(yml),
handlers = handlers2)
yaml::write_yaml(x = yml2,
file = path)
devtools::document()
library(rworkflows)
use_workflow(name = "rworkflows_static",run_pkgdown = F, force_new = T)
sessionInfo()
devoptera::args2vars(use_workflow);  docker_org <- eval(docker_org)
name="rworkflows_static"
#### Check for existing yaml ####
path <- file.path(save_dir,paste0(name,".yml"))
if(file.exists(path) &&
isFALSE(force_new)){
messager("Using existing workflow file:",path,v=verbose)
yml <- yaml::read_yaml(path)
#### Preview ####
if(isTRUE(preview)){
cat(yaml::as.yaml(yml))
}
#### Return ####
if(isTRUE(return_path)){
return(path)
} else {
return(yml)
}
}
## Custom handler prevents "on" from being converted to TRUE
yml <- get_yaml(name = name)
yml <- fill_yaml(yml=yml,
## action-level args
name=name,
tag=tag,
on=on,
branches=branches,
runners=runners,
## workflow-level args
run_bioccheck=run_bioccheck,
run_rcmdcheck=run_rcmdcheck,
as_cran=as_cran,
run_vignettes=run_vignettes,
has_testthat=has_testthat,
run_covr=run_covr,
run_pkgdown=run_pkgdown,
has_runit=has_runit,
has_latex=has_latex,
run_docker=run_docker,
github_token=github_token,
docker_user=docker_user,
docker_org=docker_org,
docker_token=docker_token,
cache_version=cache_version,
enable_act=enable_act)
#### Preview ####
if(isTRUE(preview)){
cat(yaml::as.yaml(yml))
}
cat(yaml::as.yaml(yml))
path="~/Downloads/yaml.yml"
yml <- yaml::read_yaml(
system.file("templates","rworkflows_template_static.yml",
package = "rworkflows"),
handlers = handlers)
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
action
use_workflow(name = "rworkflows_static",run_pkgdown = F, force_new = T)
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
action$runs$steps
#### Add action steps to static workflow ####
action$runs$steps[[1]]$run
#### Add action steps to static workflow ####
gsub("inputs\\.","env.",action$runs$steps[[1]]$run)
library(rworkflows)
library(rworkflows)
use_workflow(name = "rworkflows_static", run_pkgdown = F,force_new = T)
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
length(action$steps)
action$steps
length(action$runs$steps)
step=action$runs$steps[1]
step=action$runs$steps[[1]]
step
lapply(action$runs$steps,function(step){
lapply(step, function(x){
gsub("inputs\\.","env.",x)
})
})
library(rworkflows)
use_workflow(name = "rworkflows_static", run_pkgdown = F,force_new = T)
library(rworkflows)
use_workflow(name = "rworkflows_static", run_pkgdown = F,force_new = T)
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
library(rworkflows)
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
#### Add action steps to static workflow ####
yml$jobs$rworkflows_static$steps <-
lapply(action$runs$steps,function(step){
lapply(step, function(x){
## Get args from 'env.' (for workflows)
## instead of 'inputs.' (for actions)
if(is.list(x)){
lapply(x,gsub,pattern = "inputs\\.",replacement = "env.")
} else {
gsub("inputs\\.","env.",x)
}
})
})
lapply(action$runs$steps,function(step){
lapply(step, function(x){
## Get args from 'env.' (for workflows)
## instead of 'inputs.' (for actions)
if(is.list(x)){
lapply(x,gsub,pattern = "inputs\\.",replacement = "env.")
} else {
gsub("inputs\\.","env.",x)
}
})
})
library(rworkflows)
use_workflow(name = "rworkflows_static", run_pkgdown = F,force_new = T)
usethis::use_test()
.Platform$OS.type
usethis::use_test()
usethis::use_test()
is.character(TRUE)
#### Add action steps to static workflow ####
recurse <- function(x,
fun=function(x){
gsub("inputs\\.","env.",x)
}){
if(is.list(x)){
recurse(x = x,
fun = fun)
} else {
fun(x)
}
}
#### Add action steps to static workflow ####
recurse <- function(x,
fun=function(x){
gsub("inputs\\.","env.",x)
}){
if(is.list(x)){
recurse(x = x,
fun = fun)
} else if(is.character(x)){
fun(x)
} else {
x
}
}
#### Read in action to avoid code redundancy ####
## Import the latest version of action.yml
action <- yaml::read_yaml(
"https://github.com/neurogenomics/rworkflows/raw/master/action.yml")
recurse(action$runs$steps)
#### Add action steps to static workflow ####
recurse <- function(x,
fun=function(x){
gsub("inputs\\.","env.",x)
}){
if(is.list(x)){
lapply(x, recurse, fun=fun)
} else if(is.character(x)){
fun(x)
} else {
x
}
}
recurse(action$runs$steps)
library(rworkflows)
use_workflow(name = "rworkflows_static", run_pkgdown = F,force_new = T)
usethis::use_test()
biocviews2 <- infer_biocviews(include_branch = FALSE)
testthat::expect_null(biocviews2)
testthat::expect_equal("WorkflowManagement")
testthat::expect_equal(biocviews2,"WorkflowManagement")
biocviews_manual = c("Software","Genetics","Transcriptomics")
biocviews_manual = c("Software","Genetics","Transcriptomics")
biocviews3 <- infer_biocviews(biocviews = biocviews_manual)
testthat::expect_equal(biocviews3,biocviews_manual)
biocviews_manual
biocviews_manual = c("Software","Genetics","Transcriptomics")
testthat::expect_equal(biocviews3,c(biocviews_manual,"WorkflowManagement"))
#### Errors ####
testthat::expect_error(
infer_biocviews(branch = "typo")
)
testthat::expect_error(
infer_biocviews(type = "typo")
)
devtools::document()
library(rworkflows)
biocviews2 <- infer_biocviews(include_branch = FALSE)
biocviews2
testthat::is_testing()
devtools::document()
library(rworkflows)
/rlang::checkd
?rlang::check_dots_empty0
devtools::document()
library(rworkflows)
usethis::gh_token_help()
BiocManager::install("biocthis")
gh::gh_token()
usethis::create_github_token()
usethis::create_github_token()
?usethis::create_github_token()
usethis::create_github_token
